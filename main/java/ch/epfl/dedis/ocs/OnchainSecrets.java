package ch.epfl.dedis.ocs;

import ch.epfl.dedis.lib.*;
import ch.epfl.dedis.proto.OCSProto;
import ch.epfl.dedis.proto.SkipBlockProto;
import ch.epfl.dedis.proto.SkipchainProto;
import com.google.protobuf.ByteString;

import javax.xml.bind.DatatypeConverter;
import java.util.ArrayList;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * dedis/lib
 * OnchainSecrets.java
 * Purpose: Implementing all communication with the cothority to set-up,
 * check, write and read documents from the skipchain.
 *
 * @author Linus Gasser <linus.gasser@epfl.ch>
 * @version 0.2 17/09/19
 */

public class OnchainSecrets {
    // ocsID is the current ID of the onchain-secret skipchain. For multiple
    // runs on the ocs-skipchain, this ID must be initialized to the same
    // value as before.
    public byte[] ocsID;
    // X is the public key of the ocs-shard that will re-encrypt the symmetric
    // keys if they receive a valid re-encryption request.
    public Crypto.Point X;

    private Roster roster;
    private final Logger logger = LoggerFactory.getLogger(OnchainSecrets.class);

    /**
     * If the skipchain is already initialised, this constructor will only
     * initialise the class. Once it is initialized, you can verify it with
     * the verify()-method.
     *
     * @param group - the `public.toml`-file describing the current cothority.
     * @param ocsID - the ID of the used skipchain
     * @param X     - the aggregate public key of the ocs-shard
     */
    public OnchainSecrets(String group, byte[] ocsID, Crypto.Point X) {
        this.roster = new Roster(group);
        this.X = X;
        this.ocsID = ocsID;
    }

    /**
     * If the skipchain is already initialised, this constructor will only
     * initialise the class. Once it is initialized, you can verify it with
     * the verify()-method. This constructor will search for the shared
     * public key of the ocs-shard.
     *
     * @param group - the `public.toml`-file describing the current cothority.
     * @param ocsID - the ID of the used skipchain
     */
    public OnchainSecrets(String group, byte[] ocsID) throws Exception {
        this.roster = new Roster(group);
        this.X = getSharedPublicKey();
        this.ocsID = ocsID;
    }

    /**
     * This constructor will create a new onchain-secrets skipchain and initialize
     * all local parameters to fit the new values generated by the ocs-skipchain.
     *
     * @param group - the `public.toml`-file describing the current cothority.
     * @throws Exception
     */
    public OnchainSecrets(String group) throws Exception {
        logger.info("Setting up with group {}", group);
        roster = new Roster(group);

        createSkipchains();
    }

    /**
     * Contacts all nodes in the cothority and returns true only if _all_
     * nodes returned OK.
     *
     * @return true only if all nodes are OK, else false.
     * @throws CothorityError
     */
    public Boolean verify() throws CothorityError {
        Boolean ok = true;
        for (ServerIdentity n : roster.Nodes) {
            logger.info("Testing node {}", n.Address);
            try {
                n.GetStatus();
            } catch (Exception e) {
                logger.warn("Failing node {}", n.Address);
                ok = false;
            }
        }
        ;
        return ok;
    }

    /**
     * Creates a new skipchain and sets up a new ocs-shard. If a previous
     * skipchain has been setup, it still exists and can be accessed with
     * another OnchainSecrets-instance.
     *
     * @throws Exception
     */
    public void createSkipchains() throws Exception {
        OCSProto.CreateSkipchainsRequest.Builder request =
                OCSProto.CreateSkipchainsRequest.newBuilder();
        request.setRoster(roster.getProto());

        ByteString msg = roster.SendMessage("OnChainSecrets/CreateSkipchainsRequest",
                request.build());

        OCSProto.CreateSkipchainsReply reply =
                OCSProto.CreateSkipchainsReply.parseFrom(msg);
        X = new Crypto.Point(reply.getX());
        logger.debug("Got reply: {}", reply.toString());
        ocsID = reply.getSB().getHash().toByteArray();
        logger.info("Initialised OCS: {}", ocsID);
    }

    /**
     * Adds a new account to the skipchain. This is mostly useful for accounts that
     * need more access-control than just READ_ACCESS for documents.
     * <p>
     * In the current implementation, no account needs to be stored on the
     * skipchain.
     * <p>
     * TODO: perhaps this should directly take Darcs instaed of accounts, or perhaps
     * Account should incorporate all ALLOW_PUBLISH and other access-rights.
     *
     * @param admin      - the admin account - not used for the moment
     * @param newAccount - the new account to be added to the skipchain.
     * @throws Exception
     */
    public void addAccountToSkipchain(Account admin, Account newAccount) throws Exception {
        Darc d = new Darc(newAccount.ID);
        d.points.add(newAccount.Point);

        OCSProto.EditDarcRequest.Builder request =
                OCSProto.EditDarcRequest.newBuilder();
        request.setDarc(d.getProto());
        request.setOcs(ByteString.copyFrom(ocsID));

        ByteString msg = roster.SendMessage("OnChainSecrets/EditDarcRequest",
                request.build());

        OCSProto.EditDarcReply reply =
                OCSProto.EditDarcReply.parseFrom(msg);
        logger.debug("received reply: {}", reply.toString());
        logger.info("Updated darc: {}", DatatypeConverter.printHexBinary(reply.getSb().getHash().toByteArray()));
    }

    /**
     * returns the shared key of the DKG that must be used to encrypt the
     * symmetric encryption key. This will be the same as OnchainSecrets.X
     * stored when creating the skipchain.
     *
     * @return the aggregate public key of the ocs-shard
     * @throws Exception
     */
    //
    public Crypto.Point getSharedPublicKey() throws Exception {
        OCSProto.SharedPublicRequest.Builder request =
                OCSProto.SharedPublicRequest.newBuilder();
        request.setGenesis(ByteString.copyFrom(ocsID));

        ByteString msg = roster.SendMessage("OnChainSecrets/SharedPublicRequest", request.build());
        OCSProto.SharedPublicReply reply =
                OCSProto.SharedPublicReply.parseFrom(msg);
        logger.info("Got shared public key");
        return new Crypto.Point(reply.getX());
    }

    /**
     * Publishes a document on the skipchain. The publisher-account has the right
     * to add readers to the document once the document is stored on the skipchain.
     * The document will be encrypted, except for the id, the reader-list and
     * the extraData-field.
     *
     * @param doc - the document to store on the skipchain
     * @param publisher - the publisher with the right to sell read-access to the document
     * @return
     * @throws Exception
     */
    public Document publishDocument(Document doc, Account publisher) throws Exception {
        Document docNew = new Document(doc);
        docNew.readers = new Darc();
        docNew.readers.accounts.add(new Darc.DarcLink(publisher));

        OCSProto.WriteRequest.Builder request =
                OCSProto.WriteRequest.newBuilder();
        request.setWrite(docNew.getWrite(X));
        request.setReader(docNew.readers.getProto());
        request.setOcs(ByteString.copyFrom(ocsID));
        request.setData(ByteString.copyFrom(docNew.extraData));

        ByteString msg = roster.SendMessage("OnChainSecrets/WriteRequest",
                request.build());

        OCSProto.WriteReply reply =
                OCSProto.WriteReply.parseFrom(msg);
        docNew.id = reply.getSb().getHash().toByteArray();
        System.out.println("Published document " + DatatypeConverter.printHexBinary(docNew.id));
        return docNew;
    }

    /**
     * Reads a Darc from the skipchain so that it can be updated and stored
     * again. The node will return the latest available darc, although there
     * is no proof that it is really the latest.
     *
     * @param darcID - the ID of the requested darc.
     * @param recursive - whether all included darcs should also be returned.
     * @return - a list of all darcs.
     * @throws Exception
     */
    public List<Darc> readDarc(byte[] darcID, Boolean recursive) throws Exception {
        OCSProto.ReadDarcRequest.Builder request =
                OCSProto.ReadDarcRequest.newBuilder();
        request.setOcs(ByteString.copyFrom(ocsID));
        request.setDarcId(ByteString.copyFrom(darcID));
        request.setRecursive(recursive);
        ByteString msg = roster.SendMessage("OnChainSecrets/ReadDarcRequest", request.build());

        OCSProto.ReadDarcReply reply =
                OCSProto.ReadDarcReply.parseFrom(msg);
        List<Darc> darcs = new ArrayList<>();
        reply.getDarcList().forEach(d -> darcs.add(new Darc(d)));
        logger.debug("Got following darcs: {}", darcs);
        logger.info("Read darcs");
        return darcs;
    }

    /**
     * This adds the consumer to the list of people allowed to make a read-request
     * to the document.
     *
     * @param d - the document the reader should have access to
     * @param publisher - the owner of the document
     * @param reader - he will have access to make a read-request
     * @throws Exception
     */
    //
    public void giveReadAccessToDocument(Document d, Account publisher, Account reader) throws Exception {
        List<Darc> darcs = readDarc(d.readers.id, false);
        Darc darc = darcs.get(0);
        darc.version++;
        darc.points.add(reader.Point);

        // TODO: sign this new Darc with the readers-account

        OCSProto.EditDarcRequest.Builder request =
                OCSProto.EditDarcRequest.newBuilder();
        request.setOcs(ByteString.copyFrom(ocsID));
        request.setDarc(darc.getProto());

        ByteString msg = roster.SendMessage("OnChainSecrets/EditDarcRequest",
                request.build());

        OCSProto.EditDarcReply reply =
                OCSProto.EditDarcReply.parseFrom(msg);
        logger.info("Read-access granted: {}", DatatypeConverter.printHexBinary(reply.getSb().getHash().toByteArray()));
    }

    /**
     * Create a read-request on the skipchain. The nodes will verify that the
     * reader actually has access to the document and log the successful
     * read-request. A subsequent request can be made to get the re-encryption
     * key.
     *
     * @param dID - the document the reader wants to access
     * @param reader - he must have read-permissions for the document
     * @return - the read-request ID if the request was successful
     * @throws Exception
     */
    public byte[] readRequest(byte[] dID, Account reader) throws Exception {
        OCSProto.OCSRead.Builder ocsRead =
                OCSProto.OCSRead.newBuilder();
        ocsRead.setPublic(reader.Point.toProto());
        ocsRead.setDataId(ByteString.copyFrom(dID));
        ocsRead.setSignature(new Crypto.SchnorrSig(dID, reader).toProto());

        OCSProto.ReadRequest.Builder request =
                OCSProto.ReadRequest.newBuilder();
        request.setOcs(ByteString.copyFrom(ocsID));
        request.setRead(ocsRead);

        ByteString msg = roster.SendMessage("OnChainSecrets/ReadRequest", request.build());

        OCSProto.ReadReply reply =
                OCSProto.ReadReply.parseFrom(msg);
        logger.info("Created a read-request");
        return reply.getSb().getHash().toByteArray();
    }

    /**
     * Requests a skipblock and returns it.
     *
     * @param id - the id of the skipblock
     * @return - the proto-representation of the skipblock.
     * @throws Exception
     */
    public SkipBlockProto.SkipBlock getSkipblock(byte[] id) throws Exception {
        SkipchainProto.GetSingleBlock request =
                SkipchainProto.GetSingleBlock.newBuilder().build();
        ByteString msg = roster.SendMessage("Skipchain/GetSingleBlock",
                request);

        SkipBlockProto.SkipBlock reply =
                SkipBlockProto.SkipBlock.parseFrom(msg);
        logger.debug("Got the following skipblock: {}", reply);
        logger.info("Successfully read skipblock");
        return reply;
    }

    /**
     * Requests the re-encryption key from the skipchain.
     *
     * TODO: depending on how we decide to implement the access-rights, this
     * might go away.
     *
     * @param id - the read-id
     * @return - a DecryptKey that can be applied to the document to decrypt it.
     * @throws Exception
     */
    public DecryptKey decryptKey(byte[] id) throws Exception {
        OCSProto.DecryptKeyRequest.Builder request =
                OCSProto.DecryptKeyRequest.newBuilder();
        request.setReadId(ByteString.copyFrom(id));
        ByteString msg = roster.SendMessage("OnChainSecrets/DecryptKeyRequest",
                request.build());

        OCSProto.DecryptKeyReply reply =
                OCSProto.DecryptKeyReply.parseFrom(msg);
        logger.info("got decryption key");
        return new DecryptKey(reply);
    }
}
