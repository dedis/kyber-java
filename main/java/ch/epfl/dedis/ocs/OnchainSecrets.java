package ch.epfl.dedis.ocs;

import ch.epfl.dedis.lib.CothorityCommunicationException;
import ch.epfl.dedis.lib.Crypto;
import ch.epfl.dedis.lib.DecryptKey;
import ch.epfl.dedis.lib.Roster;
import ch.epfl.dedis.lib.ServerIdentity;
import ch.epfl.dedis.proto.OCSProto;
import ch.epfl.dedis.proto.SkipBlockProto;
import ch.epfl.dedis.proto.SkipchainProto;
import com.google.protobuf.ByteString;

import javax.xml.bind.DatatypeConverter;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;

import com.google.protobuf.InvalidProtocolBufferException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * dedis/lib
 * OnchainSecrets.java
 * Purpose: Implementing all communication with the cothority to set-up,
 * check, write and read documents from the skipchain.
 *
 * @author Linus Gasser <linus.gasser@epfl.ch>
 * @version 0.2 17/09/19
 */

public class OnchainSecrets {
    // ocsID is the current ID of the onchain-secret skipchain. For multiple
    // runs on the ocs-skipchain, this ID must be initialized to the same
    // value as before.
    public byte[] ocsID;
    // X is the public key of the ocs-shard that will re-encrypt the symmetric
    // keys if they receive a valid re-encryption request.
    public Crypto.Point X;

    private Roster roster;
    private final Logger logger = LoggerFactory.getLogger(OnchainSecrets.class);

    /**
     * If the skipchain is already initialised, this constructor will only
     * initialise the class. Once it is initialized, you can verify it with
     * the verify()-method. This constructor will search for the shared
     * public key of the ocs-shard.
     *
     * @param roster - list of all cothority servers with public keys
     * @param ocsID  - the ID of the used skipchain
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    OnchainSecrets(Roster roster, byte[] ocsID) throws CothorityCommunicationException {
        this.ocsID = ocsID;
        this.roster = roster;
        this.X = getSharedPublicKey();
    }

    /**
     * This constructor will create a new onchain-secrets skipchain and initialize
     * all local parameters to fit the new values generated by the ocs-skipchain.
     *
     * @param roster - list of all cothority servers with public keys
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    OnchainSecrets(Roster roster) throws CothorityCommunicationException {
        this.roster = roster;
        createSkipchains(); // this call internally set ocsID and X
    }

    /**
     * Contacts all nodes in the cothority and returns true only if _all_
     * nodes returned OK.
     *
     * @return true only if all nodes are OK, else false.
     */
    public boolean verify() {
        boolean ok = true;
        for (ServerIdentity n : roster.getNodes()) {
            logger.info("Testing node {}", n.getAddress());
            try {
                n.GetStatus();
            } catch (Exception e) {
                logger.warn("Failing node {}", n.getAddress());
                ok = false;
            }
        }
        return ok;
    }

    /**
     * Creates a new skipchain and sets up a new ocs-shard. If a previous
     * skipchain has been setup, it still exists and can be accessed with
     * another OnchainSecrets-instance.
     *
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    public void createSkipchains() throws CothorityCommunicationException {
        OCSProto.CreateSkipchainsRequest.Builder request =
                OCSProto.CreateSkipchainsRequest.newBuilder();
        request.setRoster(roster.getProto());

        ByteString msg = roster.SendMessage("OnChainSecrets/CreateSkipchainsRequest",
                request.build());

        try {
            OCSProto.CreateSkipchainsReply reply = OCSProto.CreateSkipchainsReply.parseFrom(msg);
            X = new Crypto.Point(reply.getX());
            logger.debug("Got reply: {}", reply.toString());
            ocsID = reply.getSB().getHash().toByteArray();
            logger.info("Initialised OCS: {}", ocsID);
        } catch (InvalidProtocolBufferException e) {
            throw new CothorityCommunicationException(e);
        }
    }

    /**
     * Adds a new account to the skipchain. This is mostly useful for accounts that
     * need more access-control than just READ_ACCESS for documents.
     * <p>
     * In the current implementation, no account needs to be stored on the
     * skipchain.
     * <p>
     * TODO: perhaps this should directly take Darcs instaed of accounts, or perhaps
     * Account should incorporate all ALLOW_PUBLISH and other access-rights.
     *
     * @param admin      - the admin account - not used for the moment
     * @param newAccount - the new account to be added to the skipchain.
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    public void addAccountToSkipchain(Account admin, Account newAccount) throws CothorityCommunicationException {
        Darc d = new Darc(newAccount.ID);
        d.points.add(newAccount.Point);

        OCSProto.EditDarcRequest.Builder request =
                OCSProto.EditDarcRequest.newBuilder();
        request.setDarc(d.getProto());
        request.setOcs(ByteString.copyFrom(ocsID));

        ByteString msg = roster.SendMessage("OnChainSecrets/EditDarcRequest",
                request.build());

        try {
            OCSProto.EditDarcReply reply = OCSProto.EditDarcReply.parseFrom(msg);

            logger.debug("received reply: {}", reply.toString());
            logger.info("Updated darc: {}", DatatypeConverter.printHexBinary(reply.getSb().getHash().toByteArray()));
        } catch (InvalidProtocolBufferException e) {
            throw new CothorityCommunicationException(e);
        }
    }

    /**
     * returns the shared key of the DKG that must be used to encrypt the
     * symmetric encryption key. This will be the same as OnchainSecrets.X
     * stored when creating the skipchain.
     *
     * @return the aggregate public key of the ocs-shard
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    //
    public Crypto.Point getSharedPublicKey() throws CothorityCommunicationException {
        OCSProto.SharedPublicRequest.Builder request =
                OCSProto.SharedPublicRequest.newBuilder();
        request.setGenesis(ByteString.copyFrom(ocsID));

        ByteString msg = roster.SendMessage("OnChainSecrets/SharedPublicRequest", request.build());

        try {
            OCSProto.SharedPublicReply reply = OCSProto.SharedPublicReply.parseFrom(msg);
            logger.info("Got shared public key");
            return new Crypto.Point(reply.getX());
        } catch (InvalidProtocolBufferException e) {
            throw new CothorityCommunicationException(e);
        }
    }

    /**
     * Publishes a document on the skipchain. The publisher-account has the right
     * to add readers to the document once the document is stored on the skipchain.
     * The document will be encrypted, except for the id, the reader-list and
     * the extraData-field.
     *
     * @param doc       - the document to store on the skipchain
     * @param publisher - the publisher with the right to sell read-access to the document
     * @return
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    public Document publishDocument(Document doc, Account publisher) throws CothorityCommunicationException {
        Document docNew = new Document(doc);
        docNew.readers = new Darc();
        // TODO: in the future document owner will be introduced and read access will be not granted to owner
        docNew.readers.accounts.add(new Darc.DarcLink(publisher));

        OCSProto.WriteRequest.Builder request =
                OCSProto.WriteRequest.newBuilder();
        request.setWrite(docNew.getWrite(X));
        request.setReader(docNew.readers.getProto());
        request.setOcs(ByteString.copyFrom(ocsID));
        request.setData(ByteString.copyFrom(docNew.extraData));

        ByteString msg = roster.SendMessage("OnChainSecrets/WriteRequest",
                request.build());

        try {
            OCSProto.WriteReply reply = OCSProto.WriteReply.parseFrom(msg);
            docNew.id = reply.getSb().getHash().toByteArray();
            logger.info("Published document " + DatatypeConverter.printHexBinary(docNew.id));
            return docNew;
        } catch (InvalidProtocolBufferException e) {
            throw new CothorityCommunicationException(e);
        }
    }

    /**
     * Reads a Darc from the skipchain so that it can be updated and stored
     * again. The node will return the latest available darc, although there
     * is no proof that it is really the latest.
     *
     * @param darcID    - the ID of the requested darc.
     * @param recursive - whether all included darcs should also be returned.
     * @return - a list of all darcs.
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    public List<Darc> readDarc(byte[] darcID, Boolean recursive) throws CothorityCommunicationException {
        OCSProto.ReadDarcRequest.Builder request =
                OCSProto.ReadDarcRequest.newBuilder();
        request.setOcs(ByteString.copyFrom(ocsID));
        request.setDarcId(ByteString.copyFrom(darcID));
        request.setRecursive(recursive);
        ByteString msg = roster.SendMessage("OnChainSecrets/ReadDarcRequest", request.build());

        try {
            OCSProto.ReadDarcReply reply = OCSProto.ReadDarcReply.parseFrom(msg);

            List<Darc> darcs = new ArrayList<>();
            reply.getDarcList().forEach(d -> darcs.add(new Darc(d)));
            logger.debug("Got following darcs: {}", darcs);
            logger.info("Read darcs");
            return darcs;

        } catch (InvalidProtocolBufferException e) {
            throw new CothorityCommunicationException(e);
        }
    }

    /**
     * This adds the consumer to the list of people allowed to make a read-request
     * to the document.
     *
     * @param d         - the document the reader should have access to
     * @param publisher - the owner of the document
     * @param reader    - he will have access to make a read-request
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    //
    public void giveReadAccessToDocument(Document d, Account publisher, Account reader) throws CothorityCommunicationException {
        List<Darc> darcs = readDarc(d.readers.id, false);
        Darc darc = darcs.get(0);
        darc.version++;
        darc.points.add(reader.Point);

        // TODO: sign this new Darc with the readers-account

        OCSProto.EditDarcRequest.Builder request =
                OCSProto.EditDarcRequest.newBuilder();
        request.setOcs(ByteString.copyFrom(ocsID));
        request.setDarc(darc.getProto());

        ByteString msg = roster.SendMessage("OnChainSecrets/EditDarcRequest",
                request.build());

        try {
            OCSProto.EditDarcReply reply = OCSProto.EditDarcReply.parseFrom(msg);
            logger.info("Read-access granted: {}", DatatypeConverter.printHexBinary(reply.getSb().getHash().toByteArray()));

        } catch (InvalidProtocolBufferException e) {
            throw new CothorityCommunicationException(e);
        }
    }

    /**
     * Create a read-request on the skipchain. The nodes will verify that the
     * reader actually has access to the document and log the successful
     * read-request. A subsequent request can be made to get the re-encryption
     * key.
     *
     * @param dID    - the document the reader wants to access
     * @param reader - he must have read-permissions for the document
     * @return - the read-request ID if the request was successful
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    public byte[] readRequest(byte[] dID, Account reader) throws CothorityCommunicationException {
        OCSProto.OCSRead.Builder ocsRead =
                OCSProto.OCSRead.newBuilder();
        ocsRead.setPublic(reader.Point.toProto());
        ocsRead.setDataId(ByteString.copyFrom(dID));
        ocsRead.setSignature(new Crypto.SchnorrSig(dID, reader).toProto());

        OCSProto.ReadRequest.Builder request =
                OCSProto.ReadRequest.newBuilder();
        request.setOcs(ByteString.copyFrom(ocsID));
        request.setRead(ocsRead);

        ByteString msg = roster.SendMessage("OnChainSecrets/ReadRequest", request.build());


        try {
            OCSProto.ReadReply reply = OCSProto.ReadReply.parseFrom(msg);
            logger.info("Created a read-request");
            return reply.getSb().getHash().toByteArray();
        } catch (InvalidProtocolBufferException e) {
            throw new CothorityCommunicationException(e);
        }
    }

    /**
     * Requests a skipblock and returns it.
     *
     * @param id - the id of the skipblock
     * @return - the proto-representation of the skipblock.
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    public SkipBlockProto.SkipBlock getSkipblock(byte[] id) throws CothorityCommunicationException {
        SkipchainProto.GetSingleBlock request =
                SkipchainProto.GetSingleBlock.newBuilder().setId(ByteString.copyFrom(id)).build();

        ByteString msg = roster.SendMessage("Skipchain/GetSingleBlock",
                request);

        try {
            SkipBlockProto.SkipBlock reply = SkipBlockProto.SkipBlock.parseFrom(msg);

            logger.debug("Got the following skipblock: {}", reply);
            logger.info("Successfully read skipblock");

            return reply;
        } catch (InvalidProtocolBufferException e) {
            throw new CothorityCommunicationException(e);
        }
    }

    /**
     * Requests the skipblock representing the write-request 'id' and returns
     * the corresponding OCSWrite-structure.
     *
     * @param id - the id of the write-request
     * @return [OCSProto.OCSWrite] - the write-request that can be used for
     * decryption
     * @throws CothorityCommunicationException in case of communication difficulties
     */

    public OCSProto.OCSWrite getWrite(byte[] id) throws CothorityCommunicationException {
        SkipBlockProto.SkipBlock sb = getSkipblock(id);
        logger.debug("Getting write-request from skipblock {}", id);
        try {
            // TODO: onchain-secrets still uses `network.Marshal` which prepends
            // a 16-byte identifier for easy unmarshalling.
            OCSProto.DataOCS data = OCSProto.DataOCS.parseFrom(sb.getData().substring(16));
            if (!data.hasWrite()) {
                throw new CothorityCommunicationException("This is not an ID from a write-request");
            }
            return data.getWrite();
        } catch (InvalidProtocolBufferException e) {
            throw new CothorityCommunicationException(e);
        }
    }

    /**
     * Requests the re-encryption key from the skipchain.
     * <p>
     * TODO: depending on how we decide to implement the access-rights, this
     * might go away.
     *
     * @param id - the read-id
     * @return - a DecryptKey that can be applied to the document to decrypt it.
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    public DecryptKey decryptKey(byte[] id) throws CothorityCommunicationException {
        OCSProto.DecryptKeyRequest.Builder request =
                OCSProto.DecryptKeyRequest.newBuilder();
        request.setReadId(ByteString.copyFrom(id));
        ByteString msg = roster.SendMessage("OnChainSecrets/DecryptKeyRequest",
                request.build());


        try {
            OCSProto.DecryptKeyReply reply = OCSProto.DecryptKeyReply.parseFrom(msg);

            logger.info("got decryption key");
            return new DecryptKey(reply);
        } catch (InvalidProtocolBufferException e) {
            throw new CothorityCommunicationException(e);
        }
    }

    public String getGenesis() {
        return new String((Base64.getEncoder().encode(ocsID)));
    }
}
