package ch.epfl.dedis.ocs;

import ch.epfl.dedis.lib.Roster;
import ch.epfl.dedis.lib.ServerIdentity;
import ch.epfl.dedis.lib.crypto.Point;
import ch.epfl.dedis.lib.darc.*;
import ch.epfl.dedis.lib.exception.CothorityCommunicationException;
import ch.epfl.dedis.lib.exception.CothorityException;
import ch.epfl.dedis.proto.DarcProto;
import ch.epfl.dedis.proto.OCSProto;
import ch.epfl.dedis.proto.SkipBlockProto;
import ch.epfl.dedis.proto.SkipchainProto;
import com.byzgen.ocsapi.EpflPermission;
import com.byzgen.ocsapi.User;
import com.byzgen.ocsapi.UserId;
import com.google.protobuf.ByteString;
import com.google.protobuf.InvalidProtocolBufferException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.xml.bind.DatatypeConverter;
import java.security.PublicKey;
import java.util.ArrayList;
import java.util.Base64;
import java.util.List;
import java.util.Set;

/**
 * dedis/lib
 * OnchainSecrets.java
 * Purpose: Implementing all communication with the cothority to set-up,
 * check, write and read documents from the skipchain.
 *
 * @author Linus Gasser <linus.gasser@epfl.ch>
 * @version 0.2 17/09/19
 */

public class OnchainSecrets {
    // ocsID is the current ID of the onchain-secret skipchain. For multiple
    // runs on the ocs-skipchain, this ID must be initialized to the same
    // value as before.
    public byte[] ocsID;
    // X is the public symmetricKey of the ocs-shard that will re-encrypt the symmetric
    // keys if they receive a valid re-encryption request.
    public Point X;

    private Roster roster;
    private final Logger logger = LoggerFactory.getLogger(OnchainSecrets.class);

    /**
     * If the skipchain is already initialised, this constructor will only
     * initialise the class. Once it is initialized, you can verify it with
     * the verify()-method. This constructor will search for the shared
     * public symmetricKey of the ocs-shard.
     *
     * @param roster list of all cothority servers with public keys
     * @param ocsID  the ID of the used skipchain
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    OnchainSecrets(Roster roster, byte[] ocsID) throws CothorityCommunicationException {
        this.ocsID = ocsID;
        this.roster = roster;
        this.X = getSharedPublicKey();
    }

    /**
     * This constructor will create a new onchain-secrets skipchain and initialize
     * all local parameters to fit the new values generated by the ocs-skipchain.
     *
     * @param roster list of all cothority servers with public keys
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    OnchainSecrets(Roster roster, Darc writers) throws CothorityCommunicationException {
        this.roster = roster;
        createSkipchains(writers); // this call internally sets ocsID and X
    }

    /**
     * Contacts all nodes in the cothority and returns true only if _all_
     * nodes returned OK.
     *
     * @return true only if all nodes are OK, else false.
     */
    public boolean verify() {
        boolean ok = true;
        for (ServerIdentity n : roster.getNodes()) {
            logger.info("Testing node {}", n.getAddress());
            try {
                n.GetStatus();
            } catch (Exception e) {
                logger.warn("Failing node {}", n.getAddress());
                ok = false;
            }
        }
        return ok;
    }

    /**
     * Creates a new skipchain and sets up a new ocs-shard. If a previous
     * skipchain has been setup, it still exists and can be accessed with
     * another OnchainSecrets-instance.
     *
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    public void createSkipchains(Darc writers) throws CothorityCommunicationException {
        OCSProto.CreateSkipchainsRequest.Builder request =
                OCSProto.CreateSkipchainsRequest.newBuilder();
        request.setRoster(roster.getProto());
        request.setWriters(writers.ToProto());

        ByteString msg = roster.SendMessage("OnChainSecrets/CreateSkipchainsRequest",
                request.build());

        try {
            OCSProto.CreateSkipchainsReply reply = OCSProto.CreateSkipchainsReply.parseFrom(msg);
            X = new Point(reply.getX());
            logger.debug("Got reply: {}", reply.toString());
            ocsID = reply.getOcs().getHash().toByteArray();
            logger.info("Initialised OCS: {}", DatatypeConverter.printHexBinary(ocsID));
        } catch (InvalidProtocolBufferException e) {
            throw new CothorityCommunicationException(e);
        }
    }

    /**
     * Updates an existing account or adds a new account to the skipchain. This is mostly useful for accounts that
     * need more access-control than just READ_ACCESS for documents.
     * <p>
     *
     * @param newAccount the new account to be added to the skipchain.
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    public void updateDarc(Darc newAccount) throws CothorityCommunicationException, Exception {
        OCSProto.UpdateDarc.Builder request =
                OCSProto.UpdateDarc.newBuilder();
        request.setOcs(ByteString.copyFrom(ocsID));
        request.setDarc(newAccount.ToProto());

        ByteString msg = roster.SendMessage("OnChainSecrets/UpdateDarc",
                request.build());

        try {
            OCSProto.UpdateDarcReply reply = OCSProto.UpdateDarcReply.parseFrom(msg);

            logger.debug("received reply: {}", reply.toString());
            logger.info("Updated darc {} stored in block: {}",
                    DatatypeConverter.printHexBinary(newAccount.ID()),
                    DatatypeConverter.printHexBinary(reply.getSb().getHash().toByteArray()));
        } catch (InvalidProtocolBufferException e) {
            throw new CothorityCommunicationException(e);
        }
    }

    /**
     * returns the shared symmetricKey of the DKG that must be used to encrypt the
     * symmetric encryption symmetricKey. This will be the same as OnchainSecrets.X
     * stored when creating the skipchain.
     *
     * @return the aggregate public symmetricKey of the ocs-shard
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    //
    public Point getSharedPublicKey() throws CothorityCommunicationException {
        OCSProto.SharedPublicRequest.Builder request =
                OCSProto.SharedPublicRequest.newBuilder();
        request.setGenesis(ByteString.copyFrom(ocsID));

        ByteString msg = roster.SendMessage("OnChainSecrets/SharedPublicRequest", request.build());

        try {
            OCSProto.SharedPublicReply reply = OCSProto.SharedPublicReply.parseFrom(msg);
            logger.info("Got shared public symmetricKey");
            return new Point(reply.getX());
        } catch (InvalidProtocolBufferException e) {
            throw new CothorityCommunicationException(e);
        }
    }

    /**
     * Publishes a document on the skipchain. The publisher-account has the right
     * to add owner to the document once the document is stored on the skipchain.
     * The document will be encrypted, except for the id, the reader-list and
     * the extraData-fieldElement.
     *
     * @param doc       the document to store on the skipchain
     * @param publisher the publisher with the right to sell read-access to the document
     * @return
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    public Document publishDocument(Document doc, Signer publisher) throws CothorityCommunicationException, Exception {
        Document docNew = new Document(doc);

        OCSProto.WriteRequest.Builder request =
                OCSProto.WriteRequest.newBuilder();
        request.setWrite(docNew.getWrite(X));
        request.setReaders(docNew.owner.ToProto());
        request.setOcs(ByteString.copyFrom(ocsID));
        request.setSignature(new DarcSignature(doc.owner.ID(), doc.owner, publisher, SignaturePath.USER).ToProto());
        // TODO: add correct signature here so that only writers can access the chain.

        ByteString msg = roster.SendMessage("OnChainSecrets/WriteRequest",
                request.build());

        try {
            OCSProto.WriteReply reply = OCSProto.WriteReply.parseFrom(msg);
            docNew.id = reply.getSb().getHash().toByteArray();
            logger.info("Published document " + DatatypeConverter.printHexBinary(docNew.id));
            return docNew;
        } catch (InvalidProtocolBufferException e) {
            throw new CothorityCommunicationException(e);
        }
    }

    /**
     * Gets a darc-path starting from the base to the identity given. This darc-path
     * is the shortest, most up-to-date path at the moment of reply. Of course an
     * update might happen just before you actually use it, and your signature might
     * be rejected then.
     *
     * @param base     where to start the path
     * @param identity which identity to find
     * @return a DarcPath
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    public SignaturePath getDarcPath(byte[] base, Identity identity, int role) throws CothorityCommunicationException {
        OCSProto.GetDarcPath.Builder request =
                OCSProto.GetDarcPath.newBuilder();
        request.setOcs(ByteString.copyFrom(ocsID));
        request.setBasedarcid(ByteString.copyFrom(base));
        request.setIdentity(identity.ToProto());
        request.setRole(role);
        ByteString msg = roster.SendMessage("OnChainSecrets/GetDarcPath", request.build());

        try {
            OCSProto.GetDarcPathReply reply = OCSProto.GetDarcPathReply.parseFrom(msg);
            List<Darc> darcs = new ArrayList<>();
            for (DarcProto.Darc d :
                    reply.getPathList()) {
                darcs.add(new Darc(d));
            }
            return new SignaturePath(darcs, identity, role);
        } catch (InvalidProtocolBufferException e) {
            throw new CothorityCommunicationException(e);
        } catch (Exception e) {
            throw new CothorityCommunicationException(e.toString());
        }
    }

    /**
     * Convenience function that will add a new identity to a darc. The new darc
     * will be stored on the skipchain if the signer has the right to evolve it.
     *
     * @param darc        the latest version of the darc that needs to be udpated
     * @param newIdentity the identity to add to the darc
     * @param signer      who is allowed to evolve the darc - one of the owners
     * @return the new darc
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    //
    public Darc addIdentityToDarc(Darc darc, Identity newIdentity, Signer signer) throws CothorityCommunicationException, Exception {
        Darc newDarc = darc.Copy();
        newDarc.AddUser(newIdentity);
        newDarc.SetEvolution(darc, null, signer);
        updateDarc(newDarc);
        return newDarc;
    }

    /**
     * Overloaded method for convenience.
     *
     * @param d
     * @param newIdentity
     * @param signer
     * @return
     * @throws Exception
     */
    public Darc addIdentityToDarc(Darc d, Signer newIdentity, Signer signer) throws Exception {
        Identity newI = IdentityFactory.New(newIdentity);
        return addIdentityToDarc(d, newI, signer);
    }

    /**
     * Create a read-request on the skipchain. The nodes will verify that the
     * reader actually has access to the document and log the successful
     * read-request. A subsequent request can be made to get the re-encryption
     * symmetricKey.
     *
     * @param dID    the document the reader wants to access
     * @param signer he must have read-permissions for the document
     * @return the read-request ID if the request was successful
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    public byte[] readRequest(byte[] dID, Signer signer) throws CothorityCommunicationException, Exception {
        OCSProto.Write document = getWrite(dID);
        Darc readerDarc = new Darc(document.getReader());
        SignaturePath path = getDarcPath(readerDarc.ID(), IdentityFactory.New(signer), SignaturePath.USER);

        for (Darc d : path.GetDarcs()) {
            logger.debug("Path: " + d.toString());
        }

        OCSProto.Read.Builder ocsRead =
                OCSProto.Read.newBuilder();
        ocsRead.setReader(readerDarc.ToProto());
        ocsRead.setDataid(ByteString.copyFrom(dID));
        ocsRead.setSignature(new DarcSignature(dID, path, signer).ToProto());

        OCSProto.ReadRequest.Builder request =
                OCSProto.ReadRequest.newBuilder();
        request.setOcs(ByteString.copyFrom(ocsID));
        request.setRead(ocsRead);

        ByteString msg = roster.SendMessage("OnChainSecrets/ReadRequest", request.build());


        try {
            OCSProto.ReadReply reply = OCSProto.ReadReply.parseFrom(msg);
            logger.info("Created a read-request");
            return reply.getSb().getHash().toByteArray();
        } catch (InvalidProtocolBufferException e) {
            throw new CothorityCommunicationException(e);
        }
    }

    /**
     * Requests a skipblock and returns it.
     *
     * @param id the id of the skipblock
     * @return the proto-representation of the skipblock.
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    public SkipBlockProto.SkipBlock getSkipblock(byte[] id) throws CothorityCommunicationException {
        SkipchainProto.GetSingleBlock request =
                SkipchainProto.GetSingleBlock.newBuilder().setId(ByteString.copyFrom(id)).build();

        ByteString msg = roster.SendMessage("Skipchain/GetSingleBlock",
                request);

        try {
            SkipBlockProto.SkipBlock reply = SkipBlockProto.SkipBlock.parseFrom(msg);

            logger.debug("Got the following skipblock: {}", reply);
            logger.info("Successfully read skipblock");

            return reply;
        } catch (InvalidProtocolBufferException e) {
            throw new CothorityCommunicationException(e);
        }
    }

    /**
     * Requests the skipblock representing the write-request 'id' and returns
     * the corresponding OCSWrite-structure.
     *
     * @param id the id of the write-request
     * @return [OCSProto.Write] the write-request that can be used for
     * decryption
     * @throws CothorityCommunicationException in case of communication difficulties
     */

    public OCSProto.Write getWrite(byte[] id) throws CothorityCommunicationException {
        SkipBlockProto.SkipBlock sb = getSkipblock(id);
        logger.debug("Getting write-request from skipblock {}", id);
        try {
            OCSProto.Transaction data = OCSProto.Transaction.parseFrom(sb.getData());
            if (!data.hasWrite()) {
                throw new CothorityCommunicationException("This is not an ID from a write-request");
            }
            return data.getWrite();
        } catch (InvalidProtocolBufferException e) {
            throw new CothorityCommunicationException(e);
        }
    }

    /**
     * Requests the re-encryption symmetricKey from the skipchain.
     * <p>
     * TODO: depending on how we decide to implement the access-rights, this
     * might go away.
     *
     * @param id the read-id
     * @return a DecryptKey that can be applied to the document to decrypt it.
     * @throws CothorityCommunicationException in case of communication difficulties
     */
    public DecryptKey decryptKey(byte[] id) throws CothorityCommunicationException {
        OCSProto.DecryptKeyRequest.Builder request =
                OCSProto.DecryptKeyRequest.newBuilder();
        request.setRead(ByteString.copyFrom(id));
        ByteString msg = roster.SendMessage("OnChainSecrets/DecryptKeyRequest",
                request.build());


        try {
            OCSProto.DecryptKeyReply reply = OCSProto.DecryptKeyReply.parseFrom(msg);

            logger.info("got decryption symmetricKey");
            return new DecryptKey(reply, X);
        } catch (InvalidProtocolBufferException e) {
            throw new CothorityCommunicationException(e);
        }
    }

    public String getGenesis() {
        return new String((Base64.getEncoder().encode(ocsID)));
    }


    /**
     * Create user in skipchain system. Created user will have specified permissions.
     *
     * @param administrator administrator who is going to create a user - signature of administrator will be required
     *                      to execute operation.
     * @param newUserKey    public key of new created user
     * @param permissions   initial permissions of a new user
     * @return ID of a new user
     * @throws CothorityCommunicationException in case of communication problems
     */
    public UserId createSkipchainUser(User administrator, PublicKey newUserKey, Set<EpflPermission> permissions) throws CothorityException {
        // implementation work temporary blocked by #36
        // bit mask form permission can be get in this way int perms =  EpflPermission.maskOf(permissions);
        throw new IllegalStateException("Not implemented yet");
    }
}
